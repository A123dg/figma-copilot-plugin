{"version":3,"file":"code.js","mappings":";;;;;;;;;;AAAa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qCAAqC,mBAAO,CAAC,4CAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0CAA0C;AACnE;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0CAA0C;AAC/D;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uCAAuC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,UAAU,GAAG,UAAU,GAAG,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc,GAAG,cAAc,GAAG,cAAc;AAC/E;AACA;AACA;AACA,+BAA+B,cAAc,EAAE,0BAA0B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,EAAE,GAAG,EAAE;AAChC,+BAA+B,oIAAoI;AACnK;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE,GAAG,EAAE,GAAG,EAAE;AAC1C,kCAAkC,OAAO,SAAS,+HAA+H;AACjL;AACA;AACA;AACA,4HAA4H;AAC5H;AACA;AACA;AACA;AACA,2BAA2B,uCAAuC;AAClE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA,uBAAuB,gCAAgC;AACvD,KAAK;AACL,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,YAAY,6CAA6C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iCAAiC;AACtE;AACA;AACA,+BAA+B,6BAA6B,mBAAmB;AAC/E,+BAA+B,8CAA8C;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oCAAoC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,+BAA+B,4BAA4B,wCAAwC;AACnG,+BAA+B,0CAA0C;AACzE;AACA;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,wBAAwB,WAAW;AACvE;AACA;AACA,+BAA+B,iCAAiC,qCAAqC;AACrG,+BAA+B,sDAAsD;AACrF;AACA;AACA;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,wBAAwB,WAAW;AACvE,mCAAmC,+BAA+B,mBAAmB;AACrF,mCAAmC,uCAAuC,WAAW;AACrF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA,2CAA2C,cAAc;AACzD;AACA,2DAA2D,aAAa,GAAG,UAAU;AACrF;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,qCAAqC,yBAAyB;AAC9D;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2LAA2L;AACnO;AACA,kCAAkC,uNAAuN;AACzP;AACA,+CAA+C,OAAO;AACtD,+BAA+B,4CAA4C;AAC3E;AACA;AACA,+BAA+B,+IAA+I;AAC9K;AACA,CAAC;;;;;;;;;;;;;;;;;UCpdD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UE5BA;UACA;UACA;UACA","sources":["webpack://figma-copilot-plugin/./src/code.ts","webpack://figma-copilot-plugin/webpack/bootstrap","webpack://figma-copilot-plugin/webpack/before-startup","webpack://figma-copilot-plugin/webpack/startup","webpack://figma-copilot-plugin/webpack/after-startup"],"sourcesContent":["\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst index_html_1 = __importDefault(require(\"./ui/index.html\"));\r\nfunction round10(n) {\r\n    return Math.round(n / 10) * 10;\r\n}\r\nfunction parseFills(node) {\r\n    const fills = node === null || node === void 0 ? void 0 : node.fills;\r\n    if (!fills || fills === figma.mixed || !Array.isArray(fills))\r\n        return [];\r\n    return fills.map((f) => {\r\n        var _a, _b, _c;\r\n        if (f.type === 'SOLID') {\r\n            return {\r\n                type: 'SOLID',\r\n                color: { r: f.color.r, g: f.color.g, b: f.color.b },\r\n                opacity: (_a = f.opacity) !== null && _a !== void 0 ? _a : 1,\r\n            };\r\n        }\r\n        if (f.type === 'LINEAR_GRADIENT' || f.type === 'RADIAL_GRADIENT') {\r\n            return { type: f.type, opacity: (_b = f.opacity) !== null && _b !== void 0 ? _b : 1 };\r\n        }\r\n        if (f.type === 'IMAGE') {\r\n            return { type: 'IMAGE', opacity: (_c = f.opacity) !== null && _c !== void 0 ? _c : 1 };\r\n        }\r\n        return { type: 'OTHER' };\r\n    });\r\n}\r\nfunction parseStrokes(node) {\r\n    const strokes = node === null || node === void 0 ? void 0 : node.strokes;\r\n    if (!strokes || strokes === figma.mixed || !Array.isArray(strokes))\r\n        return [];\r\n    return strokes.map((s) => {\r\n        var _a, _b, _c, _d;\r\n        return ({\r\n            color: { r: s.color.r, g: s.color.g, b: s.color.b },\r\n            opacity: (_a = s.opacity) !== null && _a !== void 0 ? _a : 1,\r\n            weight: (_b = s.weight) !== null && _b !== void 0 ? _b : 1,\r\n            align: (_c = s.strokeAlign) !== null && _c !== void 0 ? _c : 'INSIDE',\r\n            type: (_d = s.type) !== null && _d !== void 0 ? _d : 'SOLID',\r\n        });\r\n    });\r\n}\r\nfunction parseBorderRadius(node) {\r\n    var _a, _b, _c, _d;\r\n    if (!('cornerRadius' in node))\r\n        return undefined;\r\n    const cr = node.cornerRadius;\r\n    if (cr === figma.mixed) {\r\n        try {\r\n            return [\r\n                (_a = node.topLeftRadius) !== null && _a !== void 0 ? _a : 0,\r\n                (_b = node.topRightRadius) !== null && _b !== void 0 ? _b : 0,\r\n                (_c = node.bottomRightRadius) !== null && _c !== void 0 ? _c : 0,\r\n                (_d = node.bottomLeftRadius) !== null && _d !== void 0 ? _d : 0,\r\n            ];\r\n        }\r\n        catch (_e) {\r\n            return undefined;\r\n        }\r\n    }\r\n    return typeof cr === 'number' ? cr : undefined;\r\n}\r\nfunction parseAutoLayout(node) {\r\n    var _a, _b, _c, _d, _e, _f, _g;\r\n    if (!('layoutMode' in node) || node.layoutMode === 'NONE')\r\n        return undefined;\r\n    return {\r\n        direction: node.layoutMode,\r\n        gap: (_a = node.itemSpacing) !== null && _a !== void 0 ? _a : 0,\r\n        paddingTop: (_b = node.paddingTop) !== null && _b !== void 0 ? _b : 0,\r\n        paddingRight: (_c = node.paddingRight) !== null && _c !== void 0 ? _c : 0,\r\n        paddingBottom: (_d = node.paddingBottom) !== null && _d !== void 0 ? _d : 0,\r\n        paddingLeft: (_e = node.paddingLeft) !== null && _e !== void 0 ? _e : 0,\r\n        alignItems: (_f = node.primaryAxisAlign) !== null && _f !== void 0 ? _f : 'MIN',\r\n        justifyContent: (_g = node.counterAxisAlign) !== null && _g !== void 0 ? _g : 'MIN',\r\n    };\r\n}\r\nconst MAX_DEPTH = 8;\r\nconst MAX_NODES = 600;\r\nlet nodeCount = 0;\r\nfunction scanNode(node, depth) {\r\n    var _a, _b, _c;\r\n    if (nodeCount >= MAX_NODES)\r\n        return null;\r\n    nodeCount++;\r\n    const base = {\r\n        id: node.id,\r\n        name: node.name,\r\n        type: node.type,\r\n        x: Math.round(node.x * 100) / 100,\r\n        y: Math.round(node.y * 100) / 100,\r\n        width: Math.round(node.width * 100) / 100,\r\n        height: Math.round(node.height * 100) / 100,\r\n        visible: node.visible,\r\n        opacity: (_a = node.opacity) !== null && _a !== void 0 ? _a : 1,\r\n    };\r\n    const n = node;\r\n    const fills = parseFills(n);\r\n    if (fills.length)\r\n        base.fills = fills;\r\n    const strokes = parseStrokes(n);\r\n    if (strokes.length)\r\n        base.strokes = strokes;\r\n    const br = parseBorderRadius(n);\r\n    if (br !== undefined)\r\n        base.borderRadius = br;\r\n    // auto-layout\r\n    if (node.type === 'FRAME' || node.type === 'COMPONENT' || node.type === 'INSTANCE') {\r\n        const al = parseAutoLayout(n);\r\n        if (al)\r\n            base.autoLayout = al;\r\n    }\r\n    // TEXT\r\n    if (node.type === 'TEXT') {\r\n        base.text = n.characters;\r\n        base.fontSize = n.fontSize === figma.mixed ? undefined : n.fontSize;\r\n        base.fontFamily = n.fontName === figma.mixed ? undefined : (_b = n.fontName) === null || _b === void 0 ? void 0 : _b.family;\r\n        base.fontWeight = n.fontName === figma.mixed ? undefined : (_c = n.fontName) === null || _c === void 0 ? void 0 : _c.style;\r\n        base.textAlign = n.textAlignHorizontal === figma.mixed ? undefined : n.textAlignHorizontal;\r\n        const tf = fills.find((f) => f.type === 'SOLID');\r\n        if (tf === null || tf === void 0 ? void 0 : tf.color)\r\n            base.textColor = tf.color;\r\n    }\r\n    // INSTANCE\r\n    if (node.type === 'INSTANCE') {\r\n        const mainComp = node.mainComponent;\r\n        if (mainComp)\r\n            base.componentName = mainComp.name;\r\n    }\r\n    // IMAGE fill flag\r\n    if (fills.some((f) => f.type === 'IMAGE')) {\r\n        base.imageUrl = null;\r\n    }\r\n    // children\r\n    if ('children' in node && depth < MAX_DEPTH) {\r\n        const children = [];\r\n        for (const child of node.children) {\r\n            const scanned = scanNode(child, depth + 1);\r\n            if (scanned)\r\n                children.push(scanned);\r\n        }\r\n        if (children.length)\r\n            base.children = children;\r\n    }\r\n    return base;\r\n}\r\nfunction scanDocument() {\r\n    var _a, _b, _c, _d, _e, _f, _g;\r\n    nodeCount = 0;\r\n    const pages = [];\r\n    const fontSet = new Set();\r\n    const colorSet = new Map();\r\n    for (const page of figma.root.children) {\r\n        const screens = [];\r\n        for (const node of page.children) {\r\n            const scanned = scanNode(node, 0);\r\n            if (scanned)\r\n                screens.push(scanned);\r\n        }\r\n        pages.push({ id: page.id, name: page.name, screens });\r\n    }\r\n    function collectStyles(nodes) {\r\n        for (const n of nodes) {\r\n            if (n.fills) {\r\n                for (const f of n.fills) {\r\n                    if (f.type === 'SOLID' && f.color) {\r\n                        const key = `${f.color.r},${f.color.g},${f.color.b}`;\r\n                        colorSet.set(key, f.color);\r\n                    }\r\n                }\r\n            }\r\n            if (n.textColor) {\r\n                const key = `${n.textColor.r},${n.textColor.g},${n.textColor.b}`;\r\n                colorSet.set(key, n.textColor);\r\n            }\r\n            if (n.fontFamily)\r\n                fontSet.add(`${n.fontFamily} ${n.fontWeight || 'Regular'}`);\r\n            if (n.children)\r\n                collectStyles(n.children);\r\n        }\r\n    }\r\n    for (const p of pages)\r\n        collectStyles(p.screens);\r\n    const sizeCount = new Map();\r\n    const bgCount = new Map();\r\n    for (const p of pages) {\r\n        for (const s of p.screens) {\r\n            if (s.type !== 'FRAME')\r\n                continue;\r\n            const w = round10(s.width);\r\n            const h = round10(s.height);\r\n            const k = `${w}x${h}`;\r\n            sizeCount.set(k, { w, h, count: ((_b = (_a = sizeCount.get(k)) === null || _a === void 0 ? void 0 : _a.count) !== null && _b !== void 0 ? _b : 0) + 1 });\r\n            const solidBg = (_c = s.fills) === null || _c === void 0 ? void 0 : _c.find((f) => f.type === 'SOLID');\r\n            if (solidBg === null || solidBg === void 0 ? void 0 : solidBg.color) {\r\n                const r = Math.round(solidBg.color.r * 100) / 100;\r\n                const g = Math.round(solidBg.color.g * 100) / 100;\r\n                const b = Math.round(solidBg.color.b * 100) / 100;\r\n                const bk = `${r},${g},${b}`;\r\n                bgCount.set(bk, { rgb: { r, g, b }, count: ((_e = (_d = bgCount.get(bk)) === null || _d === void 0 ? void 0 : _d.count) !== null && _e !== void 0 ? _e : 0) + 1 });\r\n            }\r\n        }\r\n    }\r\n    const bestSize = (_f = [...sizeCount.values()].sort((a, b) => b.count - a.count)[0]) !== null && _f !== void 0 ? _f : { w: 1440, h: 900, count: 1 };\r\n    const bestBg = (_g = [...bgCount.values()].sort((a, b) => b.count - a.count)[0]) === null || _g === void 0 ? void 0 : _g.rgb;\r\n    return {\r\n        pages,\r\n        styleHints: {\r\n            defaultSize: { width: bestSize.w, height: bestSize.h },\r\n            defaultBg: bestBg,\r\n            allColors: [...colorSet.values()],\r\n            allFonts: [...fontSet],\r\n        },\r\n        meta: {\r\n            totalNodes: nodeCount,\r\n            maxDepth: MAX_DEPTH,\r\n            maxNodes: MAX_NODES,\r\n            truncated: nodeCount >= MAX_NODES,\r\n        },\r\n    };\r\n}\r\nfunction ensurePage(name) {\r\n    const existing = figma.root.children.find((p) => p.name === name);\r\n    if (existing)\r\n        return existing;\r\n    const page = figma.createPage();\r\n    page.name = name;\r\n    return page;\r\n}\r\nfunction normName(s) {\r\n    return s.trim().toLowerCase();\r\n}\r\nfunction generateScreens(names, targetPageName = 'Generated') {\r\n    const scan = scanDocument();\r\n    const targetPage = ensurePage(targetPageName);\r\n    figma.currentPage = targetPage;\r\n    const existing = new Set();\r\n    for (const p of scan.pages)\r\n        for (const s of p.screens)\r\n            existing.add(normName(s.name));\r\n    const wanted = names.map((n) => n.trim()).filter(Boolean);\r\n    const missing = wanted.filter((n) => !existing.has(normName(n)));\r\n    const skippedExisting = wanted.filter((n) => existing.has(normName(n)));\r\n    const { width, height } = scan.styleHints.defaultSize;\r\n    const bg = scan.styleHints.defaultBg;\r\n    const created = [];\r\n    const gapX = 200;\r\n    const gapY = 200;\r\n    const cols = 3;\r\n    missing.forEach((name, i) => {\r\n        const frame = figma.createFrame();\r\n        frame.name = name;\r\n        frame.resize(width, height);\r\n        if (bg)\r\n            frame.fills = [{ type: 'SOLID', color: bg }];\r\n        frame.x = (i % cols) * (width + gapX);\r\n        frame.y = Math.floor(i / cols) * (height + gapY);\r\n        targetPage.appendChild(frame);\r\n        created.push({ id: frame.id, name: frame.name });\r\n    });\r\n    return { created, skippedExisting };\r\n}\r\nfunction generateFromPrompt(prompt, targetPageName = 'From Prompt') {\r\n    const scan = scanDocument();\r\n    const targetPage = ensurePage(targetPageName);\r\n    figma.currentPage = targetPage;\r\n    const { width: defaultWidth, height: defaultHeight } = scan.styleHints.defaultSize;\r\n    const defaultBg = scan.styleHints.defaultBg;\r\n    const actions = [];\r\n    const applied = [];\r\n    const lines = prompt.split('|').map((s) => s.trim());\r\n    let yOffset = 0;\r\n    const itemGapY = 150;\r\n    for (const line of lines) {\r\n        if (!line)\r\n            continue;\r\n        if (line.toLowerCase().startsWith('add frame')) {\r\n            const match = line.match(/add frame\\s+['\"]([^'\"]+)['\"]/i);\r\n            if (match) {\r\n                const frameName = match[1];\r\n                const frame = figma.createFrame();\r\n                frame.name = frameName;\r\n                frame.resize(defaultWidth, defaultHeight);\r\n                if (defaultBg)\r\n                    frame.fills = [{ type: 'SOLID', color: defaultBg }];\r\n                frame.y = yOffset;\r\n                targetPage.appendChild(frame);\r\n                actions.push({ type: 'add_frame', params: { name: frameName } });\r\n                applied.push({ type: 'frame', id: frame.id, name: frameName });\r\n                yOffset += defaultHeight + itemGapY;\r\n            }\r\n        }\r\n        else if (line.toLowerCase().startsWith('add text')) {\r\n            const textMatch = line.match(/add text\\s+['\"]([^'\"]+)['\"]/i);\r\n            const posMatch = line.match(/at\\s+(\\d+),(\\d+)/i);\r\n            const sizeMatch = line.match(/size\\s+(\\d+)/i);\r\n            if (textMatch) {\r\n                const textContent = textMatch[1];\r\n                const x = posMatch ? parseInt(posMatch[1]) : 100;\r\n                const y = posMatch ? parseInt(posMatch[2]) : yOffset;\r\n                const fontSize = sizeMatch ? parseInt(sizeMatch[1]) : 16;\r\n                figma.loadFontAsync({ family: 'Roboto', style: 'Regular' }).then(() => {\r\n                    const text = figma.createText();\r\n                    text.characters = textContent;\r\n                    text.fontSize = fontSize;\r\n                    text.x = x;\r\n                    text.y = y;\r\n                    targetPage.appendChild(text);\r\n                });\r\n                actions.push({ type: 'add_text', params: { content: textContent, x, y, fontSize } });\r\n                applied.push({ type: 'text', content: textContent, x, y });\r\n            }\r\n        }\r\n        else if (line.toLowerCase().match(/add\\s+(rect|rectangle)/)) {\r\n            const sizeMatch = line.match(/(\\d+)x(\\d+)/i);\r\n            const colorMatch = line.match(/#([0-9A-F]{6})/i);\r\n            if (sizeMatch) {\r\n                const width = parseInt(sizeMatch[1]);\r\n                const height = parseInt(sizeMatch[2]);\r\n                const rect = figma.createRectangle();\r\n                rect.resize(width, height);\r\n                rect.x = 100;\r\n                rect.y = yOffset;\r\n                if (colorMatch) {\r\n                    const hex = colorMatch[1];\r\n                    const r = parseInt(hex.substring(0, 2), 16) / 255;\r\n                    const g = parseInt(hex.substring(2, 4), 16) / 255;\r\n                    const b = parseInt(hex.substring(4, 6), 16) / 255;\r\n                    rect.fills = [{ type: 'SOLID', color: { r, g, b } }];\r\n                }\r\n                targetPage.appendChild(rect);\r\n                actions.push({ type: 'add_rectangle', params: { width, height, x: 100, y: yOffset } });\r\n                applied.push({ type: 'rectangle', width, height, x: 100, y: yOffset });\r\n                yOffset += height + itemGapY;\r\n            }\r\n        }\r\n        else if (line.toLowerCase().startsWith('fill')) {\r\n            const nodeMatch = line.match(/fill\\s+(\\S+)/i);\r\n            const colorMatch = line.match(/#([0-9A-F]{6})/i);\r\n            if (nodeMatch && colorMatch) {\r\n                const nodeId = nodeMatch[1];\r\n                const hex = colorMatch[1];\r\n                const r = parseInt(hex.substring(0, 2), 16) / 255;\r\n                const g = parseInt(hex.substring(2, 4), 16) / 255;\r\n                const b = parseInt(hex.substring(4, 6), 16) / 255;\r\n                const node = figma.getNodeById(nodeId);\r\n                if (node && 'fills' in node) {\r\n                    node.fills = [{ type: 'SOLID', color: { r, g, b } }];\r\n                    actions.push({ type: 'update_fill', params: { nodeId, r, g, b } });\r\n                    applied.push({ type: 'color_update', nodeId, color: { r, g, b } });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return { actions, applied };\r\n}\r\nfunction updateNode(params) {\r\n    var _a, _b;\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const node = figma.getNodeById(params.nodeId);\r\n        if (!node)\r\n            throw new Error(`Node not found: ${params.nodeId}`);\r\n        const u = (_a = params.updates) !== null && _a !== void 0 ? _a : {};\r\n        // TEXT updates\r\n        if (node.type === 'TEXT') {\r\n            const text = node;\r\n            if (u.fontName || u.characters || u.fontSize) {\r\n                const desiredFont = (_b = u.fontName) !== null && _b !== void 0 ? _b : text.fontName;\r\n                if (desiredFont && desiredFont !== figma.mixed) {\r\n                    yield figma.loadFontAsync(desiredFont);\r\n                }\r\n            }\r\n            if (typeof u.fontSize === 'number')\r\n                text.fontSize = u.fontSize;\r\n            if (u.fontName && u.fontName.family && u.fontName.style) {\r\n                text.fontName = { family: u.fontName.family, style: u.fontName.style };\r\n            }\r\n            if (typeof u.characters === 'string')\r\n                text.characters = u.characters;\r\n        }\r\n        // Fills\r\n        if (u.fills && 'fills' in node) {\r\n            node.fills = u.fills;\r\n        }\r\n        // Opacity\r\n        if (typeof u.opacity === 'number' && 'opacity' in node) {\r\n            node.opacity = u.opacity;\r\n        }\r\n        // Position\r\n        if (typeof u.x === 'number')\r\n            node.x = u.x;\r\n        if (typeof u.y === 'number')\r\n            node.y = u.y;\r\n        // Resize (if supported)\r\n        if (typeof u.width === 'number' && typeof u.height === 'number' && 'resize' in node) {\r\n            node.resize(u.width, u.height);\r\n        }\r\n        return { ok: true, nodeId: node.id, type: node.type };\r\n    });\r\n}\r\n/**\r\n * NEW: attach_node (re-parent existing node into a parent that supports children)\r\n * - parentId can be Frame/Group/Component/Page/etc. (any ChildrenMixin)\r\n * - nodeId is any SceneNode\r\n * - index optional: insertChild(index, node), else appendChild\r\n */\r\nfunction attachNode(params) {\r\n    var _a;\r\n    const parent = figma.getNodeById(params.parentId);\r\n    const node = figma.getNodeById(params.nodeId);\r\n    if (!parent)\r\n        throw new Error(`Parent not found: ${params.parentId}`);\r\n    if (!node)\r\n        throw new Error(`Node not found: ${params.nodeId}`);\r\n    if (!('appendChild' in parent) || typeof parent.appendChild !== 'function') {\r\n        throw new Error(`Parent cannot contain children: ${parent.type} (${parent.id})`);\r\n    }\r\n    // If node is already inside parent, no-op (still return ok)\r\n    if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.id) === parent.id) {\r\n        return { ok: true, parentId: parent.id, nodeId: node.id, parentType: parent.type, note: 'Already attached' };\r\n    }\r\n    // Move node under parent\r\n    if (typeof params.index === 'number' && Number.isFinite(params.index)) {\r\n        parent.insertChild(params.index, node);\r\n    }\r\n    else {\r\n        parent.appendChild(node);\r\n    }\r\n    return { ok: true, parentId: parent.id, nodeId: node.id, parentType: parent.type };\r\n}\r\nfigma.showUI(index_html_1.default, { width: 360, height: 140 });\r\nfigma.ui.onmessage = (msg) => __awaiter(void 0, void 0, void 0, function* () {\r\n    var _a, _b, _c, _d, _e, _f;\r\n    if ((msg === null || msg === void 0 ? void 0 : msg.type) !== 'MCP_REQUEST')\r\n        return;\r\n    const { id, method, params } = msg;\r\n    try {\r\n        let result;\r\n        if (method === 'scan_document')\r\n            result = scanDocument();\r\n        else if (method === 'generate_screens')\r\n            result = generateScreens((_a = params === null || params === void 0 ? void 0 : params.names) !== null && _a !== void 0 ? _a : [], (_b = params === null || params === void 0 ? void 0 : params.targetPageName) !== null && _b !== void 0 ? _b : 'Generated');\r\n        else if (method === 'generate_from_prompt')\r\n            result = generateFromPrompt((_c = params === null || params === void 0 ? void 0 : params.prompt) !== null && _c !== void 0 ? _c : '', (_d = params === null || params === void 0 ? void 0 : params.targetPageName) !== null && _d !== void 0 ? _d : 'From Prompt');\r\n        else if (method === 'update_node')\r\n            result = yield updateNode({ nodeId: params === null || params === void 0 ? void 0 : params.nodeId, updates: (_e = params === null || params === void 0 ? void 0 : params.updates) !== null && _e !== void 0 ? _e : {} });\r\n        else if (method === 'attach_node')\r\n            result = attachNode({ parentId: params === null || params === void 0 ? void 0 : params.parentId, nodeId: params === null || params === void 0 ? void 0 : params.nodeId, index: params === null || params === void 0 ? void 0 : params.index });\r\n        else\r\n            throw new Error(`Unknown method: ${method}`);\r\n        figma.ui.postMessage({ type: 'MCP_RESPONSE', id, ok: true, result });\r\n    }\r\n    catch (e) {\r\n        figma.ui.postMessage({ type: 'MCP_RESPONSE', id, ok: false, error: (_f = e === null || e === void 0 ? void 0 : e.message) !== null && _f !== void 0 ? _f : String(e) });\r\n    }\r\n});\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Check if module exists (development only)\n\tif (__webpack_modules__[moduleId] === undefined) {\n\t\tvar e = new Error(\"Cannot find module '\" + moduleId + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/code.ts\");\n",""],"names":[],"ignoreList":[],"sourceRoot":""}